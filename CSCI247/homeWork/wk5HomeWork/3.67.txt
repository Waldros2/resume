Scott Waldron
2/1/2017

3.67

For this exercise, we will examine the code generated by GCC for functions that have structures as arguments and return values, and from this see how these language features are typically implemented. 
The following C code has a function process having structures as argument and return values, and a function eval that calls process:

1.   typedef struct {
2.    long a[2];
3.    long *p;
4.   } strA;
5.
6.   typedef struct {
7.    long u[2];
8.    long q;
9.   } strB;
10.
11.  strB process (strA s){
12.   strB r;
13.   r.u[0] = s.a[1];
14.   r.u[1] = s.a[0];
15.   r.q    = *s.p;
16.   return r;
17.  }
18.
19.  long eval(long x, long y, long z){
20.   strA s;
21.   s.a[0] = x;
22.   s.a[1] = y;
23.   s.p = &z;
24.   strB r = process(s);
25.   return r.u[0] + r.u[1] + r.q;
26.  }

1.  process:
2.   movq	%rdi, %rax		# Hold return value --> %rax
3.   movq	24(%rsp), %rdx		# Move s.p --> %rdx
4.   movq 	(%rdx), %rdx		# Move *s.p --> %rdx
5.   movq	16(%rsp), %rcx		# Move s.a[1] --> %rcx
6.   movq	%rcx, (%rdi)		# Move s.a[1] --> r.u[0]
7.   movq	8(%rsp), %rcx		# Move s.a[0] --> %rcx
8.   movq	%rcx, 8(%rdi)  		# Move s.a[0] --> r.u[1]
9.   movq	%rdx, 16(%rdi)		# Move r.q to *s.p
10.  ret

1.  eval:
2.   subq	$104, %rsp		# Allocate 104 bytes on stack
3.   movq	%rdx, 24(%rsp)		# Store z at 24+%rsp
4.   leaq	24(%rsp), %rax		# Store &z --> %rax
5.   movq	%rdi, (%rsp)		# s.a[0] = x
6.   movq	%rsi, 8(%rsp) 		# s.a[1] = y
7.   movq	%rax, 16(%rsp) 		# s.p = &z
8.   leaq	64(%rsp), %rdi		# Store &r --> %rdi
9.   call 	process			# Call process
10.  movq	72(%rsp), %rax		# Move r.u[1] --> %rax
11.  addq	64(%rsp), %rax		# r.u[0] + %rax --> %rax 
12.  addq	80(%rsp), %rax		# r.q + %rax --> %rax
13.  addq	$104, %rsp		# Deallocate stack space
14.  ret				# return


A. We can see on line 2 of function eval that it allocates 104 bytes on the stack. Diagram the stack frame for eval, showing the values that it stores on the stack prior to the calling process.

    __________________
 96|__________________|
 88|__________________|
 80|______r.q_________|
 72|______r.u[1]______|
 64|______r.u[0]______|
 56|__________________|
 48|__________________|
 40|__________________|
 32|__________________|
 24|_______z__________|
 16|______s.p_________|
  8|_____s.a[1]_______|
  0|_____s.a[0]_______|<-- %rsp

B. What value does eval pass in its call to process?

  We can see from line 24 of the source code that eval passes argument s to process where s.a[0] = x, s.a[1] = y and s.p = &z

C. How does the code for process access the elements of strucure argument s?

  process accesses the elements of structure argument s on the stack.

D. How does the code for process set the fields of result structure r?

  process sets the fields of result structure r by using the pointer passed in as an argument.

E. Complete your diagram of the stack frame for eval, showing how eval accesses the elements of structure r following the return from process.
 
  See above (r.q = z, r.u[1] = y, r.u[0] = x)

F. What general principles can you discern about how structure values are passed as function arguments and how they are returned as function results?

  Arguments in the form of structures are passed onto the stack. If we call a function that returns a structure, we allocate space on its stack and we pass a pointer to that allocated space as an argument to the function.

    
