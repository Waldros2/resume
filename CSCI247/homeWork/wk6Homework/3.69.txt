Scott Waldron
2/8/17
3.69

You are charged with maintaining  large C program, and you come across the following code:

1.  typedef struct {
2.    int_first;
3.    a_struct a[CNT];
4.    int last;
5.  } b_struct;
6.
7.  void test(long i, b_struct *bp){
8. 
9.    int n = bp->first + bp->last;
10.   a_struct *ap = &bp->a[i];
11.   ap->x[ap->idx] = n;
12. }

The declarations of the compile-time constant CNT and the structure a_struct are in a file for which you do not have the necessary access privilege. Fortunately, you have a copy of the .o version of the code, which you are able to disssemble with the OBJDUMP program, yielding the following assembly:

    void test(long i, b_struct *bp)
    i in %rdi, bp in %rsi
1.  00000000000000000 <test>:
2.	0:	8b 8e 20 01 00 00	mov	0x120(%rsi),%ecx		#Move whatever is in offset of 0x120 of first into %ecx
3.	6:	03 0e			add	(%rsi), %ecx			#Add the contents of bp to %ecx
4.	8:	48 8d 04 bf		lea 	(%rdi,%rdi,4),%rax		#Put 4i + i into %rax
5. 	c:	48 8d 04 c6		lea	(%rsi,%rax,8),%rax		#Put 5i*8+bp into %rax
6. 	10:	48 8b 50 08		mov	0x8(%rax),%rdx			#Move whatever is 8 down from %rax into %rdx
7. 	14: 	48 63 c9		movslq	%ecx,%rcx			#Move sign extended %ecx into %rcx
8.	17: 	48 89 4c d0 10		mov 	%rcx,0x10(%rax,%rdx,8)		#
9. 	1c:	c3			retq

Using your reverse engineering skills, deduce the following:

A. The value of CNT.

We know b_struct has 3 parameters: 2 ints and array a of type a_struct of unknown number CNT. bp is the address of first while 0x120(%rsi) is the address of last. So we know last is an offset of 288. With 288 -8= 280. We see that the a_struct is 40 bytes thus, 280/40 = 7.

CNT = 7

B. A complete declaration of structure a_struct. Assume that the only fields in this structure are idx and x, and that both of these contain signed values.

We know from part A that each element of the array is of byte size 40. So our declaration would be as follows:

typedef struct{
  int idx;
  int x[idx];
} a_struct;

If it's 40 bytes we need to remove a integer worth, so 40 - 4 = 36 which leaves 36 bytes for the array of type int. 36 / 4 = 9.
x = 36 bytes
idx = 9 or 4 bytes.

