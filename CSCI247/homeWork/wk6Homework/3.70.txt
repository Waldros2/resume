Scott Waldron
2/9/17
3.70

Consider the following union declaration:

1.  union ele{
2.    struct{
3.      long *p;
4.      long y;
5.    } e1;
6.    struct {
7.      long x;
8.      union ele *next;
9.    } e2;
10. };

This declaration illustrates that structures can be embedded within unions. The following function (with some expressions omitted) operates on a linked list having these unions as list elements:

1.  void proc(union ele *up){
2.    up->e2.next->x = *(up->e2.next->p) - up->e2.next->y ;
3.  }

A. What are the offsets (in bytes) of the following fields:

e1.p = 0 bytes
e1.y = 8 bytes
e2.x = 0 bytes
e2.next = 8 bytes

B. How many total bytes does the structure require?

The structure requires a total of 16 bytes.

C. The compiler generates the following assembly code for proc:

void proc(union ele *up)
up in %rdi

1.  proc:
2.	movq	8(%rdi), %rax	#e2.next --> %rax
3.	movq	(%rax), %rdx	#e1.y --> %rdx
4. 	movq	(%rdx), %rdx	#*y --> %rdx
5.  	subq	8(%rax), %rdx	#
6.	movq	%rdx, (%rdi)	#
7.	ret			#

On the basis of this information, fill in the missing expressions in the code for proc. Hint: Some union refrences can have ambiguous interpretations. These ambiguities get resolved as you see where the references lead. There is only one answer that does not perform any casting and does not violate any type constraints.


