Scott Waldron
2/16/17

Homework Week 7

5.14

Write a version of the inner product procedure described in Problem 5.13 that uses 6 x 1 loop unrolling. For x86-64, our measurements of the unrolled version give a CPE of 1.07 for integer data but still 3.01 for both floating-point data.

1.  /* Inner product. Accumalate in temporary */
2.  void inner4(vec_ptr u, vec_ptr v, data_t *dest){
3.    long i;
4.    int length = vec_length(u);
5.    int limit = length - 5;
5.    data_t *udata = get_vec_start(u);
6.    data_t *vdata = get_vec_start(v);
7.    data_t sum = (data_t) 0;
8.
9.    for(i = 0; i < limit; i+=6){
10.     sum += udata[i] * vdata[i];
11.     sum += udata[i + 1] * vdata[i + 1];
12.     sum += udata[i + 2] * vdata[i + 2];
13.     sum += udata[i + 3] * vdata[i + 3];
14.     sum += udata[i + 4] * vdata[i + 4];
15.     sum += udata[i + 5] * vdata[i + 5];      
16.   }
17.   for (; i < length; i++)
18.     sum += udata[i] * vdata[i];
19.   *dest = sum;
20. }



A. Exlpain why any (scalar) version of an inner product procedure running on an Intel Core i7 Haswell processor cannot achieve a CPE less than 1.00.
 
Due to the clock cycles required on the Intel Core i7 Haswell processor, no scalar version of an inner product can achieve a CPE less than 1.00. The performance of program load operations depends on the pipline capability and latency of the load unit. Since the load unit can only initiate two load operations every clock cycle, the CPE cannot be less than 1.00

B. Explain why the performance for floating-point data did not improve with loop unrolling.

Because with the associative property, it had to consider the rounding with the floats and our hold up is in the floats rounding computation. 
For example, x = x OP (d[i] OP d[i + 1] is different than x = (x OP d[i]) OP d[i + 1].



5.15 

Write a version of the inner product procedure described in Problem 5.13 that uses a 6x6 loop unrolling. Our measurements for this function with x86-64 give a CPE of 1.06 for integer data and 1.01 for floating-point data. What factor limits the performance to a CPE of 1.00?

  /* Inner product. Accumalate in temporary */
  void inner4(vec_ptr u, vec_ptr v, data_t *dest){
    long i;
    int length = vec_length(u);
    int limit = length - 5;
    data_t *udata = get_vec_start(u);
    data_t *vdata = get_vec_start(v);
    data_t sum = (data_t) 0;

    for(i = 0; i < limit; i+=6){
     sum1 += udata[i] * vdata[i];
     sum2 += udata[i + 1] * vdata[i + 1];
     sum3 += udata[i + 2] * vdata[i + 2];
     sum4 += udata[i + 3] * vdata[i + 3];
     sum5 += udata[i + 4] * vdata[i + 4];
     sum6 += udata[i + 5] * vdata[i + 5];
   }
   for (; i < length; i++)
     sum1 += udata[i] * vdata[i];
   *dest = sum1 + sum2 + sum3 + sum4 + sum5 + sum6;
 }

Like the problem above, Due to the constraint of a clock cycle and that CPE means CYCLE PER ELEMENT, the program can pipeline its basic operations but it will ultimately be constrained by the load operations per clock cycle, thus CPE cannot be less than 1.00.
